% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_integration_sketched.R
\name{CFITIntegrate_sketched}
\alias{CFITIntegrate_sketched}
\title{Integration of multiple data source by fast cFIT with sketching and Stochastic Proximal Point method (SPP).}
\usage{
CFITIntegrate_sketched(
  X.list,
  r = 15,
  max.niter = 100,
  nrep = 1,
  init = NULL,
  subsample.prop = NULL,
  weight.list = NULL,
  tol = 1e-06,
  early.stopping = 50,
  time.out = 60 * 2,
  future.plan = c("sequential", "transparent", "multicore", "multisession", "cluster"),
  workers = parallel::detectCores() - 1,
  verbose = T,
  seed = 0
)
}
\arguments{
\item{X.list}{a list of m ncells-by-ngenes, gene expression matrices from m data sets}

\item{r}{scalar, dimension of common factor matrix, which can be chosen as the rough number of
identifiable cells types in the joint population (default 15).}

\item{max.niter}{integer, max number of iterations (default 100).}

\item{nrep}{integer, number of repeated runs (to reduce effect of local optimum, default 1)}

\item{init}{a list of parameters for parameter initialization. The list either contains all
parameter sets: W,lambda.list, b.list, H.list, or only W will be used if provided (default NULL).}

\item{subsample.prop}{a scalar between 0 and 1. smaller proportion with results in fast computation but less
accurate results. By default the value is set to  \code{min(5*10^4/ntotal, 1)}}

\item{weight.list}{weights for performing weighted subsampling sketching. Note that the weight.list is a list of weights
per batch. The weights for each batch is a vector of nonnegative values of the same size as the number of cells in the batch.}

\item{tol}{numeric scalar, tolerance used in stopping criteria (default 1e-5).}

\item{early.stopping}{Stop early if no improvement of objective function for this number of iterations.}

\item{time.out}{Stop after the number of minutes running.}

\item{future.plan}{plan for future parallel computation, can be chosen from 'sequential','transparent','multicore','multisession' and 'cluster'. Default is 'sequential'. Note that Rstudio does not support 'multicore'.}

\item{workers}{additional parameter for \code{future::plan()}, in cases of 'multicore','multisession' and 'cluster'.
\code{weight.list = lapply(1:length(X.list), function(j) statistical_leverage_score(X.list[[j]], k=r))}}

\item{verbose}{boolean scalar, whether to show extensive program logs (default TRUE)}

\item{seed}{random seed used (default 0)}
}
\value{
a list containing  \describe{
\item{W}{ngenes-by-r numeric matrix, estimated common factor matrix}
\item{H.list}{A list of m factor loading matrix of size ncells-by-r, estimated factor loading matrices}
\item{b.list}{A list of estimated shift vector of size p (ngenes).}
\item{lambda.list}{A list of estimated scaling vector of size p (ngenes).}
\item{convergence}{boolean, whether the algorithm converge}
\item{obj}{numeric scalar, value of the objective function at convergence or when maximum iteration achieved}
\item{obj/history}{a numeric vector, value of the objective function per iteration}
\item{deltaw}{numeric, the relative change in W (common factor matrix) measured by Frobenious norm}
\item{deltaw.history}{a vector of numeric values, the relative change in W (common factor matrix) per iteration.}
\item{niter}{integer, the iteration at convergence (or maximum iteration if not converge)}
\item{params}{list of parameters used for the algorithm: max.iter, tol, nrep, subsample.prop, weight.list}
}
}
\description{
Solve the model parameters through Iterative Nonnegative Matrix Factorization (iNMF),
by minimizing the sketched objective function \deqn{1/\tilde{N} \sum_j||SX_j -(SH_JW^T\Lambda_j  + S1_nj b_j^T)||_F^2 +
gamma \sum_{l=1}^p(\sum_{j=1}^m\tilde{n}_j/\tilde{N} \lambda_{jl}-1)^2}, with additional penalty for SPP.
}
