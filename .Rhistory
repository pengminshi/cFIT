#' @return a list containing updated parameters: H, lambda,  b
#' @export
transfer_solve_subproblem <- function(params.to.update = c("lambda", "b", "H"), X,
W, H, b, lambd, n.cores, verbose = T) {
params.to.update = match.arg(params.to.update)
if (params.to.update == "lambda") {
lambd = transfer_solve_lambda(X = X, W = W, H = H, b = b, n.cores = n.cores)
} else if (params.to.update == "b") {
b = solve_b(X = X, W = W, H = H, lambd = lambd, n.cores = n.cores)
} else {
message('transfer_solve_subproblem', '\n solve_H')
H = solve_H(X = X, W = W, lambd = lambd, b = b, n.cores = n.cores)
}
return(list(lambda = lambd, b = b, H = H))
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) lsei::pnnls(a = A,
b = X[i, ] - b, sum = 1)$x))
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) lsei::pnnls(a = A,
b = X[i, ] - b, sum = 1)$x))
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
help(pnnls)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
message(i)
lsei::pnnls(a = A,b = X[i, ] - b, sum = 1)$x
}))
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
help(pnnls)
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
message(i)
out = lsei::pnnls(a = A,b = X[i, ] - b, sum = 1)$x
message(str(out))
out
}))
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
message(i)
out = lsei::pnnls(a = A,b = X[i, ] - b, sum = 1)$x
if (length(out)!= 15){
message(str(out))
}
out
}))
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
message(i)
out = lsei::pnnls(a = A,b = X[i, ] - b, sum = 1)$x
if (length(out)!= 15){
message(str(out))
}
out
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[i, ] - b))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
message(i)
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[i, ] - b))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[1, ] - b))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[1, ] - b))
message(any(is.na(A)), any(is.infinite(A)))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[1, ] - b))
message(any(is.na(A)), ', ', any(is.infinite(A)))
message(any(is.na(lambda)), ', ', any(is.infinite(lambda)))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#'
#' @param X ncells-by-ngenes gene expression matrix
#' @param W ngenes-by-r non-negative common factor matrix
#' @param lambd nonnegative numeric scalar, scaling associated with the dataset
#' @param b nonegative scalar, shift associated with tht edataset
#' @param n.cores number of cores used for the process
#'
#' @return ncells-by-r matrix, factor loading matrix H
#' @import checkmate lsei parallel
#' @export
solve_H <- function(X, W, lambd, b, n.cores) {
# check size X n*p, W p*r, lambda p, b p
checkmate::assert_true(all(c(ncol(X), nrow(W), length(lambd)) == rep(length(b),
3)))
A = lambd * W  #p*r
message('solve_H:')
message(str(A), str(X), str( X[1, ] - b))
message(any(is.na(A)), ', ', any(is.infinite(A)))
message(any(is.na(lambd)), ', ', any(is.infinite(lambd)))
H = do.call(rbind, lapply(1:nrow(X), function(i) {
lsei::pnnls(a = A, b = X[i, ] - b, sum = 1)$x
}))
str(H)
checkmate::assert_true(any(is.na(H)) == F)
message('end')
return(H)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
tmp = exprs.list[[4]]
any(is.na(tmp))
#'  \item{lambda}{estimated scaling vector of size p (ngenes)}
#'  \item{convergence}{boolean, whether the algorithm converge}
#'  \item{obj}{numeric scalar, value of the objective function at convergence or when maximum iteration achieved}
#'  \item{niter}{integer, the iteration at convergence (or maximum iteration if not converge)}
#'  \item{delta}{numeric scalar, the relative difference in last objective update}
#'  \item{params}{list of parameters used for the algorithm: max.iter, tol, nrep}
#' }
#'
#' @import checkmate parallel
#' @export
CFITTransfer <- function(Xtarget, Wref, max.niter = 100, tol = 1e-05, init = NULL,
seed = 0, verbose = T, n.cores = parallel::detectCores() - 4) {
checkmate::assert_true(ncol(Xtarget) == nrow(Wref))
if (!is.null(rownames(Wref)) & !is.null(colnames(Xtarget))) {
checkmate::assert_true(all(rownames(Wref) == colnames(Xtarget)))
}
n = nrow(Xtarget)
# remove the genes that has na/inf/nan
has.na = apply(Xtarget, 2, function(x) any(is.na(x)))
has.inf = apply(Xtarget, 2, function(x) any(is.infinite(x)))
good.genes = which(!(has.na | has.inf))
Xtarget = Xtarget[, good.genes]
Wref = Wref[good.genes, ]
p = nrow(Wref)
set.seed(seed)
time.start = Sys.time()
# if initial values of params provide
if (all(c("lambda", "b", "H") %in% names(init))) {
params.list = list(H = init$H, b = init$b, lambda = init$lambda)
} else {
# initialize
if (verbose)
logmsg("Initialize target H, b, Lambda ...")
params.list = list(b = rep(0, p),
lambda = rep(1, p),
H = solve_H(Xtarget, W = Wref, lambd = rep(1, p), b = rep(0, p), n.cores=n.cores))
}
obj = transfer_objective_func(X = Xtarget, W = Wref, H = params.list$H, lambd = params.list$lambda,
b = params.list$b, n.cores = n.cores)
converge = F
for (iter in 1:max.niter) {
obj.old = obj
params.to.update.list = sample(c("lambda", "b", "H"), 3, replace = F)
if (verbose)
logmsg("iter ", iter, ", update by: ", paste(params.to.update.list, collapse = "->"))
for (params.to.update in params.to.update.list) {
params.list = transfer_solve_subproblem(params.to.update = params.to.update,
X = Xtarget, W = Wref, H = params.list$H, b = params.list$b, lambd = params.list$lambda,
verbose = verbose, n.cores = n.cores)
message('xx ', any(is.na(params.list$lambda)))
message('\nhere',params.to.update)
message(str(params.list$H))
}
obj = transfer_objective_func(X = Xtarget, W = Wref, H = params.list$H, lambd = params.list$lambda,
b = params.list$b, n.cores = n.cores)
delta = abs(obj - obj.old)/mean(c(obj, obj.old))
if (verbose)
logmsg("iter ", iter, ", objective=", obj, ", delta=diff/obj = ", delta)
# check if converge
if (delta < tol) {
if (verbose)
logmsg("Converge at iter ", iter, ", obj delta = ", delta)
converge = T
break
}
}
time.elapsed = difftime(time1 = Sys.time(), time2 = time.start, units = "auto")
if (verbose) {
logmsg("Finised in ", time.elapsed, " ", units(time.elapsed), "\n", "Convergence status: ",
converge, " at ", iter, " iterations\nFinal objective delta:", delta)
}
if (!is.null(rownames(Xtarget))) {
rownames(params.list$H) = rownames(Xtarget)
}
if (!is.null(colnames(Xtarget))) {
names(params.list$b) = colnames(Xtarget)
names(params.list$lambda) = colnames(Xtarget)
}
return(list(H = params.list$H, b = params.list$b, lambda = params.list$lambda,
convergence = converge, obj = obj, niter = iter, delta = delta, params = list(max.niter = max.niter,
tol = tol, Wref = Wref)))
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
#' \deqn{argmin_{lambda>=0} ||X- HW^T diag(lambd) - 1_n b^T||_F^2}
#'
#' @param X An ncells-by-ngenes gene expression matrix
#' @param W An ngenes-by-r reference low dimensional factor matrix
#' @param H A factor loading matrix of size ncells-by-r
#' @param b A numeric shift vector of size p (ngenes).
#'
#' @return numeric vector, scaling of target data with respect to the reference factor matrix
#' @import parallel
#' @export
transfer_solve_lambda <- function(X, W, H, b, n.cores) {
n = nrow(X)
A = H %*% t(W)
xmean = mean(c(X))
lambd = do.call(c, parallel::mclapply(1:ncol(X), function(l) {
a_l = A[, l]
b_l = X[, l] - b[l]
x = max(0, (a_l %*% b_l)/(a_l %*% a_l))
x[is.na(x)] = 0
}, mc.cores = n.cores))
return(lambd)
}
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
formatR::tidy_dir("R")
devtools::document()
rm(list = ls())
devtools::document()
devtools::build(vignettes = F)
library(cFIT)
library(SeuratData)
data("panc8")
# extract the raw counts and metadata for data sets from 5 technologies
data.list = split_dataset_by_batch(X=t(as.matrix(panc8@assays$RNA@counts)),
batch = panc8@meta.data$tech,
labels = panc8@meta.data$celltype,
metadata = panc8@meta.data,
dataset.name = 'panc:')
# data preprocessing
exprs.list = preprocess_for_integration(data.list$X.list, genes, scale.factor=10^4, scale=T, center=F)
# select highly variable genes
genes = select_genes(data.list$X.list, ngenes=2000, verbose=F)
# data preprocessing
exprs.list = preprocess_for_integration(data.list$X.list, genes, scale.factor=10^4, scale=T, center=F)
# perform integration to estimate Wref with data sets from 4 technologies
# run time 20 min
int.ref.out = CFITIntegrate(X.list=exprs.list[c(1,2,3,5)], r=15, verbose=T, max.niter = 50, seed=42)
# transfer: run time 10 seconds
tf.out = CFITTransfer(Xtarget=exprs.list[[4]], Wref=int.ref.out$W, seed=0, verbose=F)
log2(10)
log(10)
Hnorm = rbind(do.call(rbind, int.ref.out$H.list), tf.out$H) %*% diag(colSums(int.ref.out$W))
source = rep(c('reference','target'), c(nrow(do.call(rbind, int.ref.out$H.list)), nrow(tf.out$H)))
celltype = do.call(c, c(data.list$labels.list[c(1,2,3,5)],data.list$labels.list[4]))
umap.out = plot_umap(X=Hnorm, labels=source, min_dist = 0.1, # umap parameters
point.size = 0.6, alpha=0.8, title=NULL, legend.name='source',
cols=c('grey80','red'), seed=0)
umap.out = plot_umap(X=Hnorm, labels=source, min_dist = 0.1, # umap parameters
point.size = 0.6, alpha=0.8, title=NULL, legend.name='source',
cols=c('grey80','red'), seed=0)
p1 = umap.out$p # colored by source
p2 = plot_umap(labels=celltype, point.size = 0.5, alpha=0.5, legend.name='cell type',
emb=umap.out$emb)$p # colored by cell types
p1+p2
p1
p2
devtools::document()
devtools::build(vignettes = F)
library(cFIT)
library(SeuratData)
data("panc8")
# extract the raw counts and metadata for data sets from 5 technologies
data.list = split_dataset_by_batch(X=t(as.matrix(panc8@assays$RNA@counts)),
batch = panc8@meta.data$tech,
labels = panc8@meta.data$celltype,
metadata = panc8@meta.data,
dataset.name = 'panc:')
# select highly variable genes
genes = select_genes(data.list$X.list, ngenes=2000, verbose=F)
# data preprocessing
exprs.list = preprocess_for_integration(data.list$X.list, genes, scale.factor=10^4, scale=T, center=F)
# takes roughly 20 minutes to run
int.out = CFITIntegrate(X.list=exprs.list, r=15, n.cores=4, verbose=T, max.niter = 50, seed=0)
# takes roughly 20 minutes to run
int.out = CFITIntegrate(X.list=exprs.list, r=15, n.cores=4, verbose=F, max.niter = 50, seed=0)
rm(list = ls())
